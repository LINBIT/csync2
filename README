
About csync2
============

Csync2 is a cluster synchronization tool. It can be used to keep files on
multiple hosts in a cluster in sync. Csync2 can handle complex setups with
much more than just 2 hosts, handle file deletions and can detect conflicts.

It is expedient for HA-clusters, HPC-clusters, COWs and server farms. If
you are looking for a tool to sync your laptop with your workstation, you
better have a look at Unison (http://www.cis.upenn.edu/~bcpierce/unison/)
too.

See http://oss.linbit.com/ for more information on csync2. The csync2
subversion tree can be found at http://svn.clifford.at/csync2/.


Copyright
=========

csync2 - cluster synchronisation tool, 2nd generation
LINBIT Information Technologies GmbH <http://www.linbit.com>
Copyright (C) 2004  Clifford Wolf <clifford@clifford.at>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Installing csync2
=================

Requirements:

	- A linux system (or more/less compatible os)
	- The librsync package (incl. dev headers, at least version 0.9.5)
	- The sqlite package (incl. dev headers, at least version 2.8.13)

Build and install the binaries using:

	make install

Add the csync2 port to your /etc/services file:

	csync2	30865/tcp

Add csync2 to your /etc/inetd.conf file:

	csync2 stream tcp nowait root /usr/local/sbin/csync2 csync2 -i

Create your /etc/csync2.cfg and restart inetd.

Maybe you also want to add csync2_locheck.sh to your /root/.bash_logout
file to make sure that you never logout without syncing your changes.


csync2.cfg syntax
=================

The config file contains the definitions for all the synchronisation
groups in the cluster:

group mygroup
{
	host host1 host2 host3;
	host host4@host4-eth2;

	key /etc/csync2.key_mygroup;

	include /etc/apache;
	include /home/bob;
	exclude /home/bob/temp;
	exclude *~ .*;

	action {
		pattern /etc/apache/httpd.conf;
		pattern /etc/apache/sites-available/*;
		exec "/usr/sbin/apache2ctl graceful";
		logfile "/var/log/csync2_action.log";
		do-local;
	}
}

config /etc/csync2.cfg_anotherone;
config /etc/csync2.cfg_foo /etc/csync2.cfg_bar;

The host statement adds the hosts. Note that the names used here must
equal to the output of "hostname". If the hostname used for communication
is different from the output of the "hostname" command (e.g. if a
crossover cable with other IP addresses should be used), the syntax
"hostname@hostname-for-communication" can be used.

The key statement must be used exactly once in each group and defines
the file containing shared secret for that group. The keyfile can be
created using "csync2 -k keyfilename".

The include and exclude pattern are a bit more complex. There are two
kind of patterns: pathname-patterns starting with a slash character and
basename patterns which do not.

The last matching pattern for each of both categories is choosen. If
both categories match, the file will be synchonized.

The config keyword can be used to include another config file in this one.

Additionally a group can have action sections. Each action section has a
list of patterns and a list of commands. If any of the patterns do match
an updated file, the commands will be executed. On default, the ouput of
the commands is sent to /dev/null, however: A logfile can be specified. If
the keyword "do-local" is present in the action section, the command will
also be executed on the machine where the change has happened locally. If
the special token "%%" is present in the command text, it will be replaced
by a list of the updated files.

You might want to run "csync2 -R" after excluding some files from the config
file. This will check the database and remove the old entries which are not
matched by the config file anymore. Without that, those database entries would
ligger around forever.

It is also possible to have multiple configurations in parallel. A configuration
named 'foobar' may be stored in /etc/csync2_foobar.cfg and is used whenever csync2
is called with the option "-C foobar".


The synchronization method
==========================

Sorry, this section still needs to be written.


Using csync2
============

Simply calling csync2 without any parameters prints out a brief usage
info. Running "csync2 -x" will sync local changes to the other hosts.

Sorry, the rest of this section still needs to be written.


The database backend
====================

Sometimes it is neccessary to connect to the database backend. The
sqlite command-line tool is needed to open the database:

	# sqlite /var/lib/csync2/$HOSTNAME.db

This opens up an SQL shell where you can access the database using
standard SQL queries. Over time the database may get fragmented or
have big holes in it if many records are removed. This may slow down
the database and can be fixed by running the VACUUM command on the
database:

	# sqlite /var/lib/csync2/$HOSTNAME.db vacuum

The VACUUM command cleans the database by copying its contents to a
temporary database file and reloading the original database file from
the copy.

Especially consider running the VACUUM command after removing many files
from a config (after you did run "csync2 -R").


Bootstrapping large setups
==========================

Usually when you are running csync2 the first time after adding files
to the configuration, csync2 will detect that files as new and add them
to the dirty database. When running the first update, those files are
silently removed from the dirty DB if they exist already on the peer.

In large setups this is a significant overhead. So you might instead
choose to sync the files somehow else (e.g. using rsync) in the first
place and then just add them to the local database without adding them
to the dirty table. This can be done by running "csyncs2 -crI /".

But use the -I option with care! If the files on the machines are not
in sync, they won't be synced atomatically by csync2 because they are
not mentioned in the dirty table!

The test mode -T also supports the -I modifier - But here it has the
opposite effect. While -T is usually only good for diagnostic purposes,
it automatically creates entries in the dirty DB for unsynced files when
running with the -I modifier.

Sometimes it is usefull to disable the entire csync2 system on a node (e.g.
for preparing new files for a cluster-wide update). This can be done by
creating a file /etc/csync2.lock. When such a file exists, csync2 will
simply refuse to start.

